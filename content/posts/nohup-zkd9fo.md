---
title: 'linux: nohup & 重定向'
slug: nohup-zkd9fo
url: /post/nohup-zkd9fo.html
date: '2024-03-20 14:46:55+08:00'
lastmod: '2025-11-17 22:56:43+08:00'
toc: true
isCJKLanguage: true
tags: ["Linux", "Shell", "nohup", "重定向"]
---



# linux: nohup & 重定向

# 背景

今天在进行一些`spark-hive`的操作时, 因为对此完全不了解, 所以找好兄弟咨询了下, 他给了我一串我完全看不懂的shell命令, 本文就是专门用来解释这个命令的

# 问题

1. ​`nohup`​以及 `>`

# 代码

这段神奇的代码: `nohup spark-hive -f xx.sql > xx.log 2>&1 &`

‍

# 解释

1. ​`nohup`：

    - ​`nohup`​ 是一个命令，它可以让你运行的程序在退出终端后继续运行。当你退出登录、关闭终端或断开SSH连接时，操作系统会向所有运行的程序发送一个SIGHUP信号，通常会导致程序终止。`nohup`命令会阻止这个信号，让后续运行的程序忽略它，确保程序的持续运行。
2. ​`spark-hive`：

    - 这是启动Hive会话的命令，可能是一个自定义的脚本或别名，用于执行Hive查询。这里的假设是`spark-hive`是利用Spark引擎执行Hive查询的命令。
3. ​`-f xx.sql`：

    - ​`-f`​ 参数代表 "file"，`xx.sql`​ 是一个包含Hive SQL查询语句的文件。这个参数告诉`spark-hive`命令读取该文件并执行文件中定义的SQL语句。
4. ​`>`：

    - 这个符号是输出重定向操作符，用于将命令的标准输出（通常显示在终端上的输出）重定向到一个文件上。
    - ​`xx.log`​ 是输出文件的名称。这意味着命令 `spark-hive -f xx.sql`​ 的标准输出（正常的输出）不会显示在终端上，而是会被写入到 `xx.log` 这个文件中。
5. ​`2>&1`：

    - 这是一个特殊的重定向形式，用于将标准错误（stderr，即错误消息）重定向到标准输出（stdout，正常输出）。
    - ​`2`​ 代表标准错误，`1`​ 代表标准输出。所以 `2>&1`​ 的意思是将错误信息也输出到`xx.log`文件中，与正常的输出合并。
6. ​`&`：

    - 这个符号用于将命令置于后台执行。它让这个命令在子shell中运行，这意味着即使你的终端关闭，这个命令仍然在后台运行。
    - 这允许你继续在同一终端中运行其他命令，而该命令会在后台无干扰地运行。

总结一下，`nohup spark-hive -f xx.sql > xx.log 2>&1 &` 这个命令的作用是：

- 无论终端是否关闭，都在后台安静地启动一个`spark-hive`​进程来运行`xx.sql`文件中的Hive SQL语句。
- 将所有的正常输出和错误输出都保存到`xx.log`文件中，以供后续审查。

# 重定向的引申

1. **进程替换**：在一些Shell脚本中，你可以使用`2>&1`​与`>(命令)`结合来实现进程替换，这能将标准输出和错误输出同时送入一个命令的标准输入中。例如：

    ```shell
    some_command 2>&1 | another_command
    ```
2. **日志文件分割**：虽然`2>&1`​将标准输出和错误输出合并到一个文件，但有时你可能想要分别处理。你可以先用`2>&1`​合并，然后用`tee`命令分割它们，例如：

    ```shell
    some_command 2>&1 | tee logfile.log
    ```
    这样可以在屏幕上显示输出的同时，也将其写入日志文件。
3. **错误输出的丢弃**：如果你想忽略错误输出而只关心标准输出，可以将错误输出重定向到空设备`/dev/null`：

    ```shell
    some_command > output.log 2>/dev/null
    ```
4. **错误和输出的交换**：有时你可能想要交换标准输出和错误输出的目的地，可以这样做：

    ```shell
    some_command 3>&1 1>&2 2>&3
    ```
    这里使用了文件描述符3作为临时的存储。
5. **在脚本中动态处理错误**：你可以将错误输出重定向到一个管道中，并在管道的另一端动态处理这些错误：

    ```shell
    some_command 2> >(error_handling_command)
    ```
    这可以用于实时分析错误信息或将错误信息发送到某个日志服务。
6. **使用exec批量处理文件描述符**：在脚本开始处使用`exec`命令可以为整个脚本的所有命令设置文件描述符的重定向，比如：

    ```shell
    exec 2>> error.log
    ```
    这样脚本中后续所有命令的错误输出都会追加到`error.log`中。
7. **在命令行中快速检查命令的成功与否**：

    ```shell
    some_command 2>&1 >/dev/null | grep '错误关键词'
    ```
    如果`some_command`​产生了包含`错误关键词`​的错误输出，即使标准输出被重定向到`/dev/null`​，使用`grep`也可以捕捉到错误信息。
8. **调试脚本**：当编写复杂的Shell脚本时，你可能想要看到执行过程中的每个命令及其输出和错误，这时可以使用：

    ```shell
    set -x
    ```
    它会将执行的每个命令及其标准输出和错误输出打印到终端，这是一个很好的调试工具。
